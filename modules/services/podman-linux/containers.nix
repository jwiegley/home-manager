{ config, lib, ... }:

with lib;


let
  createQuadletSource = name: containerDef:
  let
    ifNotNull = condition: text: if condition != null then text else "";
    ifNotEmptyList = list: text: if list != [] then text else "";
    ifNotEmptySet = set: text: if set != {} then text else "";
    
    serviceName = if containerDef.serviceName != null then containerDef.serviceName else name;
    containerName = name; # Use the submodule name as the container name

    formatEnvironment = env:
      if env != {} then
        concatStringsSep " " (mapAttrsToList (k: v: "${k}=${v}") env)
      else
        "";

    formatPorts = ports:
      if ports != [] then
        concatStringsSep "\n" (map (port: "PublishPort=${port}") ports)
      else
        "";

    formatVolumes = volumes:
      if volumes != [] then
        concatStringsSep "\n" (map (volume: "Volume=${volume}") volumes)
      else
        "";
    
    formatDevices = devices:
      if devices != [] then
        concatStringsSep "\n" (map (device: "AddDevice=${device}") devices)
      else
        "";

    formatCapabilities = action: capabilities:
      if capabilities != [] then
        concatStringsSep "\n" (map (capability: "${action}Capability=${capability}") capabilities)
      else
        "";

    formatLabels = labels:
      if labels != [] then
        concatStringsSep "\n" (map (label: "Label=${label}") labels)
      else
        "";

    formatAutoUpdate = autoupdate:
      if autoupdate == "registry" then
        "AutoUpdate=registry"
      else if autoupdate == "local" then
        "AutoUpdate=local"
      else
        "";

    # TODO: check that the user hasn't supplied both networkMode and networks
    formatNetwork = containerDef: 
      if containerDef.networkMode != null then
        "Network=${containerDef.networkMode}"
      else if containerDef.networks != [] then
        "Network=${concatStringsSep "," containerDef.networks}"
      else
        "";
    
    formatUnitTags = tagList:
      if tagList != [] then
        concatStringsSep " " (map (tag: "${tag}") tagList)
      else
        "";

    formatExtraArgs = containerDef:
      let
        networkAliasArg = if containerDef.networkAlias != null then "--network-alias ${containerDef.networkAlias}" else "";
        entrypointArg = if containerDef.entrypoint != null then "--entrypoint '${containerDef.entrypoint}'" else "";
        allArgs = [networkAliasArg entrypointArg] ++ containerDef.extraOptions;
      in
        if allArgs != [] && allArgs != [""] then
          "PodmanArgs=${concatStringsSep " " (filter (arg: arg != null && arg != "") allArgs)}"
        else
          "";

      configText = ''
        # Automatically generated by home-manager podman containers module
        # DO NOT EDIT THIS FILE DIRECTLY
        #  
        # ${serviceName}.container
        [Unit]
        Description=${if containerDef.description != null then containerDef.description else "Service for container ${containerName}"}
        After=network.target ${formatUnitTags containerDef.unitConfig.After}
        ${ifNotEmptyList containerDef.networks "After=podman-networks-hm.service"}

        [Container]
        ContainerName=${containerName}
        Image=${containerDef.image}
        ${ifNotEmptySet containerDef.environment "Environment=${formatEnvironment containerDef.environment}"}
        ${ifNotNull containerDef.environmentFile "EnvironmentFile=${containerDef.environmentFile}"}
        ${ifNotEmptyList containerDef.ports (formatPorts containerDef.ports)}
        ${ifNotNull containerDef.user "User=${containerDef.user}"}
        ${ifNotNull containerDef.userNS "UserNS=${containerDef.userNS}"}
        ${ifNotNull containerDef.group "Group=${containerDef.group}"}
        ${ifNotNull containerDef.networkMode "Network=${containerDef.networkMode}"}
        ${formatNetwork containerDef}
        ${ifNotNull containerDef.ip4 "IP=${containerDef.ip4}"}
        ${ifNotNull containerDef.ip6 "IP6=${containerDef.ip6}"}
        ${ifNotEmptyList containerDef.volumes (formatVolumes containerDef.volumes)}
        ${ifNotEmptyList containerDef.devices (formatDevices containerDef.devices)}
        ${formatAutoUpdate containerDef.autoupdate}
        ${ifNotEmptyList containerDef.addCapabilities (formatCapabilities "Add" containerDef.addCapabilities)}
        ${ifNotEmptyList containerDef.dropCapabilities (formatCapabilities "Drop" containerDef.dropCapabilities)}
        ${ifNotEmptyList containerDef.labels (formatLabels containerDef.labels)}
        ${formatExtraArgs containerDef}

        [Service]
        Environment="PATH=/run/wrappers/bin:/run/current-system/sw/bin:${config.home.homeDirectory}/.nix-profile/bin"
        Restart=${containerDef.serviceConfig.Restart}
        TimeoutStopSec=${toString containerDef.serviceConfig.TimeoutStopSec}
        ${ifNotNull containerDef.serviceConfig.ExecStartPre "ExecStartPre=${containerDef.serviceConfig.ExecStartPre}"}

        [Install]
        ${if containerDef.autostart then "WantedBy=multi-user.target default.target" else ""}
      '';

      removeBlankLines = text:
        let
          lines = splitString "\n" text;
          nonEmptyLines = filter (line: line != "") lines;
        in
          concatStringsSep "\n" nonEmptyLines;

    in
    removeBlankLines configText;

  toQuadletInternal = name: containerDef:
    {
      serviceName = if containerDef.serviceName != null then containerDef.serviceName else "podman-${name}";
      source = createQuadletSource name containerDef;
      unitType = "container";
    };
in 

let  
  # Define the container user type as the user interface
  containerDefinitionType = types.submodule {
    options = {
      serviceName = mkOption {
        type = with types; nullOr str;
        description = "The name of the systemd service to generate for the container.";
        default = null;
      };

      description = mkOption {
        type = with types; nullOr str;
        description = "The description of the container.";
        default = null;
      };

      image = mkOption {
        type = types.str;
        description = "The container image.";
      };

      entrypoint = mkOption {
        type = with types; nullOr str;
        description = "The container entrypoint.";
        default = null;
      };

      environment = mkOption {
        type = with types; attrsOf str;
        default = {};
      };

      environmentFile = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      ports = mkOption {
        type = with types; listOf str;
        default = [];
      };

      user = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      userNS = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      group = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      networkMode = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      networks = mkOption {
        type = with types; listOf str;
        default = [];
      };

      ip4 = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      ip6 = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      networkAlias = mkOption {
        type = with types; nullOr str;
        default = null;
      };

      volumes = mkOption {
        type = with types; listOf str;
        default = [];
      };

      devices = mkOption {
        type = types.listOf types.str;
        default = [];
        description = "The devices to mount into the container, in the format '/dev/<host>:/dev/<container>'.";
      };

      autoupdate = mkOption {
        type = with types; enum [
          ""
          "registry"
          "local"
        ];
        default = "";
      };
      
      autostart = mkOption {
        type = types.bool;
        default = true;
      };

      addCapabilities = mkOption {
        type = with types; listOf str;
        default = [];
      };

      dropCapabilities = mkOption {
        type = with types; listOf str;
        default = [];
      };

      labels = mkOption {
        type = with types; listOf str;
        default = [];
      };

      serviceConfig = {
        TimeoutStopSec = mkOption {
          type = types.int;
          default = 30;
        };

        ExecStartPre = mkOption {
          type = with types; nullOr str;
          default = null;
        };

        Restart = mkOption {
          type = types.enum [
            "no"
            "always"
            "on-failure"
            "unless-stopped"
          ];
          default = "always";
          description = "The restart policy of the container.";
        };
      };

      unitConfig = {
        After = mkOption {
          type = with types; listOf str;
          default = [];
        };
      };

      extraOptions = mkOption {
        type = types.listOf types.str;
        default = [];
      };

    };
  };

in {

  imports = [
    ./options.nix
  ];

  options.services.podman.containers = mkOption {
    type = types.attrsOf containerDefinitionType;
    default = {};
    description = "Attribute set of container definitions.";
  };

  config = {
    internal.podman-quadlet-definitions = mapAttrsToList toQuadletInternal config.services.podman.containers;
  };
}
